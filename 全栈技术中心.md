[TOC]









# 框架



## React



### props

#### 对象组件

```js
		//创建组件
		class Person extends React.Component{
			render(){
				// console.log(this);
				const {name,age,sex} = this.props
				//props是只读的
				//this.props.name = 'jack' //此行代码会报错，因为props是只读的
				return (
					<ul>
						<li>姓名：{name}</li>
						<li>性别：{sex}</li>
						<li>年龄：{age+1}</li>
					</ul>
				)
			}
		}
		//对标签属性进行类型、必要性的限制
		Person.propTypes = {
			name:PropTypes.string.isRequired, //限制name必传，且为字符串
			sex:PropTypes.string,//限制sex为字符串
			age:PropTypes.number,//限制age为数值
			speak:PropTypes.func,//限制speak为函数
		}
		//指定默认标签属性值
		Person.defaultProps = {
			sex:'男',//sex默认值为男
			age:18 //age默认值为18
		}
```

```js
class Person extends React.Component{

			constructor(props){
				//构造器是否接收props，是否传递给super，取决于：是否希望在构造器中通过this访问props
				// console.log(props);
				super(props)
				console.log('constructor',this.props);
			}

			//对标签属性进行类型、必要性的限制
			static propTypes = {
				name:PropTypes.string.isRequired, //限制name必传，且为字符串
				sex:PropTypes.string,//限制sex为字符串
				age:PropTypes.number,//限制age为数值
			}

			//指定默认标签属性值
			static defaultProps = {
				sex:'男',//sex默认值为男
				age:18 //age默认值为18
			}
			
			render(){
				// console.log(this);
				const {name,age,sex} = this.props
				//props是只读的
				//this.props.name = 'jack' //此行代码会报错，因为props是只读的
				return (
					<ul>
						<li>姓名：{name}</li>
						<li>性别：{sex}</li>
						<li>年龄：{age+1}</li>
					</ul>
				)
			}
		}
```



#### 函数组件

```js
		//创建组件
		function Person (props){
			const {name,age,sex} = props
			return (
					<ul>
						<li>姓名：{name}</li>
						<li>性别：{sex}</li>
						<li>年龄：{age}</li>
					</ul>
				)
		}
		Person.propTypes = {
			name:PropTypes.string.isRequired, //限制name必传，且为字符串
			sex:PropTypes.string,//限制sex为字符串
			age:PropTypes.number,//限制age为数值
		}

		//指定默认标签属性值
		Person.defaultProps = {
			sex:'男',//sex默认值为男
			age:18 //age默认值为18
		}
```







### ref与事件处理

#### 字符串形式（不推荐）

```js
		//创建组件
		class Demo extends React.Component{
			//展示左侧输入框的数据
			showData = ()=>{
				const {input1} = this.refs
				alert(input1.value)
			}
			//展示右侧输入框的数据
			showData2 = ()=>{
				const {input2} = this.refs
				alert(input2.value)
			}
			render(){
				return(
					<div>
						<input ref="input1" type="text" placeholder="点击按钮提示数据"/>&nbsp;
						<button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;
						<input ref="input2" onBlur={this.showData2} type="text" placeholder="失去焦点提示数据"/>
					</div>
				)
			}
		}
		//渲染组件到页面
		ReactDOM.render(<Demo a="1" b="2"/>,document.getElementById('test'))
```



#### 回调函数形式

```js
		//创建组件
		class Demo extends React.Component{
			//展示左侧输入框的数据
			showData = ()=>{
				const {input1} = this
				alert(input1.value)
			}
			//展示右侧输入框的数据
			showData2 = ()=>{
				const {input2} = this
				alert(input2.value)
			}
			render(){
				return(
					<div>
						<input ref={c => this.input1 = c } type="text" placeholder="点击按钮提示数据"/>&nbsp;
						<button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;
						<input onBlur={this.showData2} ref={c => this.input2 = c } type="text" placeholder="失去焦点提示数据"/>&nbsp;
					</div>
				)
			}
		}
		//渲染组件到页面
		ReactDOM.render(<Demo a="1" b="2"/>,document.getElementById('test'))
```



#### creatRef

```js
		//创建组件
		class Demo extends React.Component{
            mref = react.creatRef()
			//展示左侧输入框的数据
			showData = ()=>{
                alert(this.mref.current.value)
			}
			render(){
				return(
					<div>
						<input ref={this.mref} type="text" placeholder="点击按钮提示数据"/>&nbsp;
						<button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;

					</div>
				)
			}
		}
		//渲染组件到页面
		ReactDOM.render(<Demo a="1" b="2"/>,document.getElementById('test'))
```





#### 事件处理

```js
		//创建组件
		class Demo extends React.Component{
			/* 
				(1).通过onXxx属性指定事件处理函数(注意大小写)
						a.React使用的是自定义(合成)事件, 而不是使用的原生DOM事件 —————— 为了更好的兼容性
						b.React中的事件是通过事件委托方式处理的(委托给组件最外层的元素) ————————为了的高效
				(2).通过event.target得到发生事件的DOM元素对象 ——————————不要过度使用ref
			 */
			//创建ref容器
			myRef = React.createRef()
			myRef2 = React.createRef()

			//展示左侧输入框的数据
			showData = (event)=>{
				console.log(event.target);
				alert(this.myRef.current.value);
			}

			//展示右侧输入框的数据
			showData2 = (event)=>{
				alert(event.target.value);
			}

			render(){
				return(
					<div>
						<input ref={this.myRef} type="text" placeholder="点击按钮提示数据"/>&nbsp;
						<button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;
						<input onBlur={this.showData2} type="text" placeholder="失去焦点提示数据"/>&nbsp;
					</div>
				)
			}
		}
		//渲染组件到页面
		ReactDOM.render(<Demo a="1" b="2"/>,document.getElementById('test'))
```



### state与生命周期

[State & 生命周期 – React (docschina.org)](https://react.docschina.org/docs/state-and-lifecycle.html)

```js
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  //组件被挂载时
  componentDidMount() {
  }
  
  //组件被卸载时
  componentWillUnmount() {
  }

  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```

`componentDidMount()` 方法会在组件已经被渲染到 DOM 中后运行

`componentWillUnmount()` 方法会在组件被删除时运行









































## Express







## Umi







## Storybook

[Storybook Tutorials](https://storybook.js.org/tutorials/intro-to-storybook/react/zh-CN/get-started/)





### start

#### introduce

Storybook是一种UI开发工具。它通过隔离组件使开发更快、更容易。这允许您一次处理一个组件。您可以开发整个UI，而无需启动复杂的开发堆栈、强制将某些数据放入数据库或在应用程序中导航。



使用Storybook在web应用程序中构建小型原子组件和复杂页面。如果它是一个UI，你可以用Storybook构建它。



Storybook帮助您记录组件以供重用，并自动对组件进行可视化测试以防止出现错误。用插件生态系统扩展Storybook，帮助您做一些事情，比如微调响应布局或验证可访问性。



Storybook与最流行的JavaScript UI框架集成，并且（实验性地）支持服务器呈现的组件框架，如Ruby on Rails。



#### install

Use the Storybook CLI to install it in a single command. Run this inside your *existing project’s* root directory:

```shell
# Add Storybook:
npx storybook init
```

If you run into issues with the installation, check the [Troubleshooting section](https://storybook.js.org/docs/react/get-started/install#troubleshooting) below for guidance on how to solve it.



Storybook需要安装到已使用框架设置的项目中。它不能用于空项目。

- 📦 [Create an Angular Workspace](https://angular.io/cli/new)
- 📦 [Create React App](https://reactjs.org/docs/create-a-new-react-app.html)
- 📦 [Vue CLI](https://cli.vuejs.org/)
- 📦 [Ember CLI](https://guides.emberjs.com/release/getting-started/quick-start/)

The command above will make the following changes to your local environment:

- 📦 Install the required dependencies.
- 🛠 Setup the necessary scripts to run and build Storybook.
- 🛠 Add the default Storybook configuration.
- 📝 Add some boilerplate stories to get you started.
- 📡 Set up telemetry to help us improve Storybook. Read more about it [here](https://storybook.js.org/docs/react/configure/telemetry).



Depending on your framework, first, build your app and then check that everything worked by running:

```shell
npm run storybook
```

```
yarn storybook
```

它将在本地启动Storybook并输出地址。根据您的系统配置，它会自动在新的浏览器选项卡中打开地址，并显示欢迎屏幕。



#### what’s a story

故事捕获UI组件的呈现状态。开发人员为每个组件编写多个故事，描述组件可以支持的所有“有趣”状态。



CLI创建的示例组件演示了可以使用Storybook构建的组件类型：按钮、标题和页面。



每个示例组件都有一组故事，展示了它支持的状态。您可以在UI中浏览故事，并在以.stories结尾的文件中查看故事背后的代码。js或.stories.ts。故事是用组件故事格式（CSF）编写的，CSF是一种基于ES6模块的标准，用于编写组件示例。



让我们从按钮组件开始。故事是一个描述如何呈现相关组件的函数。下面是如何在“primary”状态下呈现Button并导出一个名为primary的故事。



```js
// Button.stories.js|jsx

import React from 'react';

import { Button } from './Button';

export default {
  /* 👇 The title prop is optional.
  * See https://storybook.js.org/docs/react/configure/overview#configure-story-loading
  * to learn how to generate automatic titles
  */
  title: 'Button',
  component: Button,
};

export const Primary = () => <Button primary>Button</Button>;
```



![Initial button story](https://storybook.js.org/d1406df7f9ce817ae0e5b3eb5f1bf1f3/example-button-noargs.png)



通过在Storybook侧栏中单击渲染的按钮来查看它。

上述Story定义可以进一步改进，以利用Storybook的“args”概念。Args以机器可读的方式描述Button的参数。它开启了Storybook动态改变和撰写论点的超能力。

```js
// Button.stories.js|jsx

import React from 'react';

import { Button } from './Button';

export default {
  /* 👇 The title prop is optional.
  * See https://storybook.js.org/docs/react/configure/overview#configure-story-loading
  * to learn how to generate automatic titles
  */
  title: 'Button',
  component: Button,
};

//👇 We create a “template” of how args map to rendering
const Template = (args) => <Button {...args} />;

//👇 Each story then reuses that template
export const Primary = Template.bind({});
Primary.args = {
   primary: true,
   label: 'Button',
};
```



![Button story with args](https://storybook.js.org/ff519d6518900d4be0ce86bbf3655913/example-button-args.png)

#### Browse Stories



一个`*.stories.js`文件定义了组件的所有story。每个story都有一个相应的边栏项目。当您单击一个story时，它会在画布中呈现一个独立的预览iframe(页内框架)。



通过单击侧栏中的故事在故事之间导航。尝试侧栏搜索，按名称查找故事。

或者使用键盘快捷键。单击“故事书”菜单查看可用快捷方式列表。



storybook 内置了节省时间的工具。工具栏包含一些工具，可用于调整story在画布中的渲染方式：

🔍 通过视觉缩放可以缩放构件，以便查看详细信息。

🖼 背景更改组件后面的渲染背景，以便您可以验证组件在不同视觉上下文中的渲染方式。

📱 视口以各种尺寸和方向渲染零部件。它是检查组件响应性的理想工具。

https://storybook.js.org/8b083907d74e7f2b9a298e5f324cc751/toolbar-walkthrough-optimized.mp4



“Docs”选项卡显示关于组件的自动生成的文档（从源代码推断）。使用文档在与团队共享可重用组件时非常有用，例如在设计系统或组件库中。

https://storybook.js.org/07234fedf00ba418879c443de0764c1c/toolbar-docs-tab-optimized.mp4

**Controls** 允许您与组件的参数（输入）动态交互。尝试组件的替代配置以发现边缘情况。

**Actions** 可以帮助您验证交互通过回调产生正确的输出。例如，如果您查看Header组件的“Logged In”故事，我们可以验证单击“Log out”按钮是否触发onLogout回调，该回调将由使用Header的组件提供。

https://storybook.js.org/946b2f4bdb006e8475d21202d68b9eec/addons-walkthrough-optimized.mp4



#### Setup Storybook

[Setup Storybook](https://storybook.js.org/docs/react/get-started/setup)

从您的项目中选择一个简单的组件，如Button，然后编写一个`.stories.js`或一个`.stories.mdx`文件。它可能看起来像这样：

```js
// YourComponent.stories.js|jsx

import { YourComponent } from './YourComponent';

//👇 This default export determines where your story goes in the story list
export default {
  /* 👇 The title prop is optional.
  * See https://storybook.js.org/docs/react/configure/overview#configure-story-loading
  * to learn how to generate automatic titles
  */
  title: 'YourComponent',
  component: YourComponent,
};

//👇 We create a “template” of how args map to rendering
const Template = (args) => <YourComponent {...args} />;

export const FirstStory = {
  args: {
    //👇 The args you need here will depend on your component
  },
};
```





### Write Stories

#### Introduce







# 技术/库/工具



### creat react app配置less（失败）

#### creat react app中不暴露webpack引入less

[React中使用less(use CSS Modules)的两种配置方法 - 简书 (jianshu.com)](https://www.jianshu.com/p/94ac7250ccf0)

[React脚手架中配置less-loader和antd按需加载 - 掘金 (juejin.cn)](https://juejin.cn/post/6980539403135680525)



通常我们都是使用craco这个库配置别名，使用react-app-rewired库来配置css module，但是他们都是要求修改packjson中的scripts的脚本，这就冲突了，所以只能暴露配置文件（注意暴露文件时必须先把.git文件删除或者提交代码）



```
降低react版本

npm install react@16.x react-dom@16.x --save

```

```
npx create-react-app site
```



```


npm install react-app-rewired customize-cra
```



```
因为 create-react-app 与 react-app-rewired 是基于 webpack4 来开发的，而 less-loader 的最新版本是基于 webpack5 来开发的，所以最新版的 less-loader 是不支持我们的脚手架项目的，所以这里需要指定 less 和 less-loader 版本号

npm i  less@3.10.3 less-loader@5.0.0
npm i less-loader@5.0.0
```

```
antd按需加载

npm i babel-plugin-import -D
```



```js
//config-overrides.js
const {
	override,// 重写webpack配置
	fixBabelImports,// 修复babel导入
	addLessLoader,// 添加less-loader
	addDecoratorsLegacy,// 添加装饰器
	disableEsLint,// 禁用eslint
	addWebpackAlias// 添加webpack别名
} = require('customize-cra')
//customize-cra是一个用于修改create-react-app默认配置的库

const path = require('path')

module.exports = override(
	fixBabelImports('import', {//使antd样式生效
		libraryName: 'antd',
		libraryDirectory: 'es',
		style: true,
	}),
	addLessLoader({//addLessLoader作用是修改less的配置
		javascriptEnabled: true,
		modifyVars: {'@primary-color': '#3d74aa'},
		// modifyVars: {'@primary-color': '#f9c700'},
	}),
	addDecoratorsLegacy(),//作用是支持装饰器，装饰器是一种语法糖，可以在不改变类的情况下，为类添加新的功能
	disableEsLint(),//作用是禁用eslint,eslint是一种代码检查工具，可以检查代码是否符合规范
	addWebpackAlias({
		'@': path.resolve(__dirname, 'src'),
		'@app': path.resolve(__dirname, 'src/app'),
		'@util': path.resolve(__dirname, 'src/util'),
		'@constant': path.resolve(__dirname, 'src/constant'),
		'@component': path.resolve(__dirname, 'src/component'),
	}),
)

```

#### 不用看了，最后还是失败了，部分安装包冲突无法自动下载



### 从0-1搭建react18项目

[【React】从0到1搭建你的React18项目-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/999696#slide-4)

```
npx create-react-app site
```

调整项目结构

```
/src
  /assets         项目资源文件，比如，图片 等
  /components     通用组件
  /pages          页面
  /store          mobx 状态仓库
  /utils          工具，比如，token、axios 的封装等
  App.js          根组件
  index.css       全局样式
  index.js        项目入口
```







##### scss预处理器

```
npm i sass -D
```

##### 配置路由（非组件环境下获取路由信息）

```
npm i react-router-dom
```

1. 在 `pages` 目录中创建两个路由测试文件夹：`Login`、`Layout`
2. 分别在创建的两个目录中创建 `index.js` 文件，并创建一个简单的组件后导出：

```js
pages/Login/index.js
const Login = () => {
  return <div>login</div>
}
export default Login

```

```js
pages/Layout/index.js
const Layout = () => {
  return <div>layout</div>
}
export default Layout
```



```
npm i history
```

创建 `utils/history.js `文件

```js
//utils/history.js
// https://github.com/remix-run/react-router/issues/8264

import { createBrowserHistory } from 'history'
import { unstable_HistoryRouter as HistoryRouter } from 'react-router-dom'
const history = createBrowserHistory()

export {
  HistoryRouter,
  history
}
```

在app.js中添加路由配置

```js
import { HistoryRouter, history } from './utils/history'
import {  Route, Routes } from 'react-router-dom'
import Layout from './pages/Layout'
import Login from './pages/Login'

function App() {
  return (
  	//HistoryRouter替换BrowserRouter
    <HistoryRouter history={history}>
      <div className="App">
       <Routes>
            <Route path="/" element={<Layout/>}>
                   {/* 配置嵌套路由*/}
                {/* 二级路由默认页面 */}
                {/*<Route index element={<组件1/>} /> */}
                {/*<Route path="article" element={<Article />} /> */}
            </Route>
            <Route path="/login" element={<Login/>}/>
        </Routes>
      </div>
    </HistoryRouter>
  )
}

export default App

```



**6版本路由子组件传递不再用`props.children`而是用`<Outlet />`**







##### antd

```
npm i antd
```

`src/index.js`:

```js
// 先导入 antd 样式文件
// https://github.com/ant-design/ant-design/issues/33327
import 'antd/dist/antd.min.css'
// 再导入全局样式文件，防止样式覆盖！
import './index.scss'
```

`pages/Login/index.js`

```js
import { Button } from 'antd'

const Login = () => (
    <div>
    <Button type="primary">Button</Button>
</div>
)
export default Login
```







##### 配置别名路径

[自定义 CRA 的默认配置](https://ant.design/docs/react/use-with-create-react-app-cn#高级配置)

[craco 配置文档](https://github.com/gsoft-inc/craco/blob/master/packages/craco/README.md#configuration)

- `CRA` 将所有工程化配置，都隐藏在了 `react-scripts` 包中，所以项目中看不到任何配置信息
- 如果要修改 `CRA` 的默认配置，有以下几种方案：
  1. 通过第三方库来修改，比如，`@craco/craco` （**推荐**）
  2. 通过执行 `yarn eject` 命令，释放 `react-scripts` 中的所有配置到项目中

```
 npm i -D @craco/craco --legacy-peer-deps
```

在项目根目录中创建 craco 的配置文件：`craco.config.js`，并在配置文件中配置路径别名

```js
//craco.config.js

const path = require('path')

module.exports = {
  // webpack 配置
  webpack: {
    // 配置别名
    alias: {
      // 约定：使用 @ 表示 src 文件所在路径
      '@': path.resolve(__dirname, 'src')
    }
  }
}
```



```js
// 将 start/build/test 三个命令修改为 craco 方式
"scripts": {
  "start": "craco start",
  "build": "craco build",
  "test": "craco test",
  "eject": "react-scripts eject"
}
```



**@别名路径提示**

1. 在项目根目录创建 `jsconfig.json` 配置文件

2. 在配置文件中添加以下配置

   ```
   {
   
     "compilerOptions": {
       "baseUrl": "./",
       "paths": {
         "@/*": ["src/*"]
       }
     }
   }
   ```

vscode会自动读取`jsconfig.json` 中的配置，让vscode知道`@`就是`src`目录

##### 封装fetch请求

```js

// Example POST method implementation:
async function postData(url = '', data = {}) {
    // Default options are marked with *
    const response = await fetch(url, {
        method: 'POST', // *GET, POST, PUT, DELETE, etc
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(data) // body data type must match "Content-Type" header
    });
    return response.json(); // parses JSON response into native JavaScript objects
}

async function getData(url = '', data = {}) {
    // Default options are marked with *
    const response = await fetch(url, {
        method: 'GET', // *GET, POST, PUT, DELETE, etc
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(data) // body data type must match "Content-Type" header
    });
    return response.json(); // parses JSON response into native JavaScript objects
}


export const test = () => {
    postData('http://121.5.5.157:8000/login', {
        uid: "20050027",
        pwd: "20050027",
    })
        .then(data => {
            console.log(data); // JSON data parsed by `data.json()` call
        });
}
```



##### 全局变量

1、新建css 文件用于存放全局变量：var.css

2、文件内使用 :root{} 来存放所有变量，如新建变量 --titleHeight（css全局变量必须以--开头）

 ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0f295c7fb8246319587187253188832~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

3、引用时需要使用 var()函数，var 函数还可以接收第二个参数，表示变量的默认值，如果变量不存在，则会使用该默认值。

 ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/217546a8f12a435696b3fd2c89a16ee5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)







### vite+react+tailwindcss

##### vite项目

[Install Tailwind CSS with Vite - Tailwind CSS](https://tailwindcss.com/docs/guides/vite)

```
yarn create vite
cd 	
yarn
npm run dev
```

**vite.config.js**

```
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": "/src",
    },
  },
});

```



##### tailwindcss

```
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
```



**tailwind.config.js**

```
/** @type {import('tailwindcss').Config} */
export default {
  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
  theme: {
    extend: {},
  },
  plugins: [],
  corePlugins: {
    preflight: false,
  },
};
```

**index.css**

```
@tailwind base;
@tailwind components;
@tailwind utilities;
```

##### 路由

```
yarn add react-router-dom

```



### tailwindcss

[Tailwind CSS 中文文档 - 无需离开您的HTML，即可快速建立现代网站。](https://www.tailwindcss.cn/)

[(2 封私信 / 81 条消息) 如何评价CSS框架TailwindCSS？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/337939566)





### NVM（node版本管理工具）



[nvm安装（Windows篇） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/495053578)

### NRM（npm源管理工具）



```
npm install -g nrm
```



```
nrm ls
nrm current
nrm use xxx
nrm add xxx url
nrm del xxx
nrm test xxx
```



### WebSocket

代替http请求（短轮询或长轮询）的 一种位于应用层的基于连接的（意味着有状态）的全双工通信 网络传输协议 （常用于即时通讯）

[万字长文，一篇吃透WebSocket：概念、原理、易错常识、动手实践 - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1887095)







### Redux

状态管理工具

[示例：Todo List · Redux](https://www.redux.org.cn/docs/basics/ExampleTodoList.html)



[Redux 中文官网 - JavaScript 应用的状态容器，提供可预测的状态管理。 | Redux 中文官网](https://cn.redux.js.org/)

[访问 Store | React Redux 中文文档 (react-redux.js.org)](https://cn.react-redux.js.org/using-react-redux/accessing-store/)

[Redux核心源码分析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/85170310)







### Loadable(懒加载)（React16后使用React内置Lazy）

**路由页**

```js
import React from "react";
import { Routes, Route, BrowserRouter } from "react-router-dom";
import ReactDOM from "react-dom/client";
import { Provider } from "mobx-react";
import { configure } from "mobx";
import { ConfigProvider } from "antd";
import Loadable from "@/component/Loadable";
import zhCN from "antd/es/locale/zh_CN";

import injects from "@/store";

import "@/less/var.less";
import "@/less/com.less";

configure({ enforceActions: "observed" });

configure({ enforceActions: "observed" });

let Login = Loadable({ loader: () => import("./app/login") });
let Index = Loadable({ loader: () => import("./app/index") });
let Layout = Loadable({ loader: () => import("./app/layout") });


const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <Provider {...injects}>
    <ConfigProvider locale={zhCN}>
      <BrowserRouter>
        <Routes>
          <Route path="/login" element={<Login />} />
          <Route element={<Layout />}>
            <Route path="/" element={<Index />} />
          </Route>
        </Routes>
      </BrowserRouter>
    </ConfigProvider>
  </Provider>
);

```

**@/component/Loadable**

```js
import L from 'react-loadable'
import LoadingPage from '../LoadingPage'

const Loadable = opt => (
  L({
    loading: LoadingPage,
    delay: 300,
    ...opt
  })
)

export default Loadable
```



**LoadingPage**

```js
import React from 'react'
import Loading from 'react-loading-spinkit'

class LoadingPage extends React.Component {
  render() {
    return (
      <div style={{ height: '100vh', width: '100%' }}>
        <Loading show={true} />
      </div>
    )
  }
}

export default LoadingPage

```







### Lazy（React16后）



**routers/index.jsx**

```js
import { Navigate, Outlet } from "react-router";
import { lazy } from "react";
import Layout from "../layouts";
import Index from "../pages/home";

export default [
  {
    path: "/",
    meta: {
      isLogin: true,
    },
    component: Layout,
    children: [
      {
        path: "/",
        meta: {
          title: "Home",
          isLogin: true,
        },
        component: Index,
      },
      {
        path: "/admin",
        meta: {
          title: "Admin",
          isLogin: true,
        },
        component: lazy(() => import("../pages/admin")),
      },
      {
        path: "/manage",
        meta: {
          title: "Manage",
          isLogin: true,
        },
        component: lazy(() => import("../pages/manage")),
      },
    ],
  },
  {
    path: "/login",
    meta: {
      title: "Login",
    },
    component: lazy(() => import("../pages/login")),
  },

  // {
  //   path: '/500',
  //   meta: {
  //     title: 'Error',
  //   },
  //   component: Page500,
  // },
  // {
  //   path: '*',
  //   meta: {
  //     title: 'Page Not Found',
  //   },
  //   component: Page404,
  // },
];

```

**routers/routerBefore.jsx**

```js
import { Navigate, useRoutes } from "react-router-dom";
import routes from "./index";
import { Suspense } from "react";
import { getCookie } from "../utils";
// import LoadingScreen from "src/components/loading-screen/LoadingScreen";

function RouterBeforeEach(props) {
  document.title = ` ${props.route.meta.title} | HZNU图书馆`;
  const isLogin = !!getCookie("userInfo"); // !!转换为布尔值
  if (props?.route?.meta?.isLogin) {
    if (!isLogin) {
      return <Navigate to={"/login"} replace />;
    }
  }
  return <>{props.children}</>;
}

// 渲染路由
const renderRoutes = (Routes) =>
  Routes.map((item) => {
    const route = {
      meta: item.meta,
      path: `${item.path}`,
    };
    if (item.component) {
      route.element = (
        <Suspense fallback={<div>Loading...</div>}>
          <RouterBeforeEach route={item}>
            <item.component />
          </RouterBeforeEach>
        </Suspense>
      );
      // route.element = <item.component/>
    }
    if (item.children) {
      route.children = renderRoutes(item.children);
    }
    if (item.redirect) {
      route.element = <Navigate to={item.redirect} />;
    }
    return route;
  });

const Router = () => {
  return useRoutes(renderRoutes(routes));
};

export default Router;

```















# 听说过的





## NX

NX是一个全栈工程集成框架，提供了一套完整的解决方案和工具来实现全栈项目开发。Nx使用了诸如Cypress,Jest,Prettier,TypeScript等现代化工具来实现包括Angular、React和Node、Nest、Express等各种框架的集成开发，并且提供了深度图、依赖检测等功能，使小型团队也能使用像Google,Facebook和微软一样的开发工具和流程

https://nx.dev/





## dnf

最新的包管理工具（yum的升级版）

[Ubuntu Manpage: dnf - DNF Command Reference](https://manpages.ubuntu.com/manpages/impish/man8/dnf.8.html)









